11-19-24

t1:
I want to refactor some old C++ code I wrote, so that I can use it in another context, can you help me? The code is my attempt at implementing a pairing heap by creating a basic priority queue class to derive the pairing heap from. The base class is called "Eecs281PQ" which you will see declared as the base class and friend. Can you suggest any optimizations and/or redundancies we can refactor regarding my pairing heap implementation? Do not implement any suggestions you come up, just create a comprehensive list of them so that I can review what you came up with. For now, I have identified some code duplication regarding the destructor and update priorities functions. Please refactor these functions by abstracting away the duplicate code into a helper function called "traversalHelper" such that I can simply call the helper within the functions I mentioned and the it will seamlessly do the abstracted work. Dont forget to provide comments in all the places you refactor detailing exactly what you did. Here is the code: I supplied <PairingPQ.h> here.









































P1.1: 

I want to implement my own priority queue containers in cpp20. Generate a abstract base class that defines a minimal interface (eg the baseline operations and behavr that very simple pqs support) of a generic pq called "SPsPQ" that deafualts as a max pq and works in general; make it possible to derive other classes from it ie so that the member variables can be access from the base and from derived but not outside. only the destructor and the member functions should be available to access from outside. do not use any libs or functions that trivialize the implement like priority_queue<>, make_heap(), etc. and make sure implicit conversions are not possible when constructing an object of this base pq. the base class should handle any datatype and in the future we will implement other pqs that will use their own data structures. the goal is to eventually create a stocks trading simulator that will invoke the containers we implement, which will be derived from our SPsPQ class.  



CRIT:

Did not declare a function to update priorities and incorreclty stated that the deleted move constructor and assignment operator can be implemented in derived classes if needed. 


















P1.2:

I am getting an error regarding the template line. also once you define a function as deleted are you sure we can define them in derived classes? also modify the base class to declare update priorities . theres no need to regenerate the derived example only the base clas





CRIT:

not bad

















P1.3:

for the update priorities function, it is meant to be a function thats called when the pq is out of order and needs to restore the pq invariant so mod that. then generate a derived class within its own head file that declares and defines an unordered pq. we will use it for testing purpose. give it a range based ctor 







CRIT:

In your heapifyDown function u keep parent child indices which is a binary heap structure and your updatePriority, which should really be updatePriorities, you maintain a sorted heap property. these two aspects, and the is sorted flag you integrated, are issues that do not make an unordered pq. i dont want to use smart pointers; further, this might not be the best time to use a raw array and i see potential mem leaks so instead make data a vector. also take care to respect and adhere to const-correctness becuz u call a non const method within a const method. 



















P1.4: 

dont mix ordered and unordered concepts so omit the flag and the updatePriorities logic bcuz there is no pq invariant for unsorted pq omit sort too








CRIT:

Doesnt realize that an unordered pq should simply return the element with the highest priority, on the fly, and not worry about sorting. This wouldve been done with a simple linear search upon recieveing a request of the top element. This is the only functionality needed for testing other implementations. Also, I was not expecting an omission of the entire updatePriorities function, rather just its logic since it has to be implemented, even though empty, per the base class's pure virtual function, which is valid. A true unordered priority queue would keep elements in insertion order, do a linear search for the highest priority element (e.g., max/min), and not sort at all. 











































P2.1:

I am building a stock market simulator that accepts historical data and with a streaming algo, can determne optimal time to purch and sale commodity at the highest price but i am also building the underlying datastructures. that said i will create several to experiment with and i have started wit a simple pq so generate an derived unordered pq class that i can use to test with. it goes in its own headr file do not use any libs or functions that trivialize the implement like priority_queue<>, make_heap(), etc give it a range based ctor 



#ifndef SPSPQ_H
#define SPSPQ_H

#include <functional>  


template<typename T, typename Compare = std::less<T>>
class SPsPQ 
{
public: // INTERFACE
    
    // DTOR
    virtual ~SPsPQ() = default;

    // OPERATIONS
    virtual void push(const T& value) = 0;         
    virtual void pop() = 0;                        
    virtual const T& getTop() const = 0;                              
    virtual std::size_t getSize() const = 0;          
    virtual bool isEmpty() const = 0;
    virtual void updatePQ() = 0;             

protected: // MEMBERS
    
    // CTOR
    explicit SPsPQ(const Compare& comp = Compare())
        : compareFunctor{ comp } {}


    Compare compareFunctor;
}; // class SPsPQ

#endif // SPSPQ_H




















CRIT:

Not bad, but used a raw dynamic array.















P2.2:

explain the tradeoffs between using a raw dynamic array instead of a vector here. did u make the right choice container?












P2.3:

yes it does, but im using it for testing, and it wont drive the simulator. later more sophisticated pqs will. also, the "trivializing" part is regarding the pq implement operations not the container low level operations. lets make the next version wit this in mind ie use the vec. generate some test case that will exercise the unordered pqs edge cases and then generate another version of the unordered pq with an optimization such that its faster than the first, raw array version yet still a true unordered pq. 












CRIT:

the raw array version cannot handle custom types and requires an explicit defualt ctor, which is not robust implementation. 



The model misunderstood my intent and tested the two vector versions, yet I was expecting to test the vector versions against the raw array. However, since it tested the two vector versions, it still could not find the bug, which was embedded within push. Push has several bugs, and the one the model raised was valid but its test case could not detect it. It took a sequence of pushing 10, 20, then pop, then push(5), and an assertion(getTop == 10), to reveal it. Another push bug is that it doesnt handle the case when the new value is equal to the current top. In this case, like shown in the screenshot, after pushing two duplicate ints, followed by a pop operation, the incorrect result it accessed, i.e., a stale location. Further, its raw array pointer also has issues since it doesnt handle when a default ctor is defined regarding custom data types.

































P3:

I have implemented the following base class and derived class and i have tested all basic functionality but to move on, i must make sure this derived class always gives correct results bc i will use it as my ground truth in testing other more complex derived clases. no matter the datatype and comparator, it must return the correct results. Do you see any logic errors, and if so, supply the corresponding testcase. the derived class is supposed to be an optimized version of an unordered pq but it looks rather complex so im not sure if i implemented it right. I do not want to use any facilities that will trivialize creating the pq implemntations. if i push 10 then 20 then pop then push 5 i expect to get a result of 10 when caln top since its a maxheap but it does not. why is that?

// SPsPQ.h
//
// Base class for all special-purpose priority queues.
//
//


#ifndef SPSPQ_H
#define SPSPQ_H

#include <functional>  


template<typename T, typename Compare = std::less<T>>
class SPsPQ 
{
public: // INTERFACE
    
    // DTOR
    virtual ~SPsPQ() = default;

    // OPERATIONS
    virtual void push(const T& value) = 0;         
    virtual void pop() = 0;                        
    virtual const T& getTop() const = 0;                              
    virtual std::size_t getSize() const = 0;          
    virtual bool isEmpty() const = 0;
    virtual void updatePQ() = 0;             

protected: // MEMBERS
    
    // CTOR
    explicit SPsPQ(const Compare& comp = Compare())
        : compareFunctor{ comp } {}


    Compare compareFunctor;
}; // class SPsPQ

#endif // SPSPQ_H









// UnorderedOPT.h 

#ifndef UNORDERED_PQ_OPTIMIZED_H
#define UNORDERED_PQ_OPTIMIZED_H

#include "SPsPQ.h"  // Base class header
#include <vector>

template<typename T, typename Compare = std::less<T>>
class UnorderedPQOptimized : public SPsPQ<T, Compare> 
{

public:


    // Default constructor
    explicit UnorderedPQOptimized(const Compare& comp = Compare())
        : SPsPQ<T, Compare>(comp), topIdx(0), topValid(false) {}



    // Range-based constructor
    template<typename Iterator>
    UnorderedPQOptimized(Iterator begin, Iterator end, const Compare& comp = Compare())
        : SPsPQ<T, Compare>(comp), data(begin, end), topIdx(0), topValid(false) {
        if (!data.empty()) updateTop();
    }



    // Push a new value into the queue
    void push(const T& value) override {
        data.push_back(value);
        if (!topValid || this->compareFunctor(data[topIdx], value)) {
            topIdx = data.size() - 1;  // New element might be top
            topValid = true;
        }
    }



    // Remove the top element
    void pop() override {
        if (isEmpty()) return;

        if (!topValid) updateTop();
        
        data[topIdx] = data.back();
        data.pop_back();
        topValid = false;  // Force recheck next time
    }



    // Get the top element (highest priority)
    const T& getTop() const override {
        if (isEmpty()) {
            throw std::runtime_error("Priority queue is empty");
        }
        if (!topValid) {
            const_cast<UnorderedPQOptimized*>(this)->updateTop();  // Lazy update
        }
        return data[topIdx];
    }



    // Get the current size
    std::size_t getSize() const override {
        return data.size();
    }

    // Check if the queue is empty
    bool isEmpty() const override {
        return data.empty();
    }

    // Update function (no-op unless forced)
    void updatePQ() override {
        updateTop();  // Explicitly update if needed
    }


private:

    std::vector<T> data;      // Vector to store elements
    std::size_t topIdx;       // Index of current top element
    bool topValid;            // Flag to indicate if topIdx is valid



    // Helper to find and update the top index
    void updateTop() 
    {
        if (data.empty()) 
        {
            topValid = false;
            return;
        }

        topIdx = 0;
        for (std::size_t i = 1; i < data.size(); ++i) 
        {
            if (this->compareFunctor(data[topIdx], data[i])) {
                topIdx = i;
            }
        }
        topValid = true;
    }
};

#endif // UNORDERED_PQ_OPTIMIZED_H



























P3.4:

generate a derived class called BinPQ that implements a binary heap pq and give it a rangebased ctor. also give it two functions that will fix the tree when priorities increase "void bottomUp(size_t index)" and decrease "void topDown(size_t index)". updatepq should rebuild the heap and assume the invariant is broke. 



















P4.1:

my binpq is not returning the expected results and idk where to start debuging. can u analyse the code for any bugs and provide edge tests? i already have unit tests for basic functionality but now i need to test corner cases and edge cases. also, can u omit the magic numbers and replce them and the corresponding code? let ROOT = 1 and NUM_CHILDREN = 2. then, make sure that any redundancies and/or code duplication is brought to my attention. note that i do not want to use any facilities that will trivialize the pq implementation however I do want to use efficient methods and the stl for lowlevel container operations like lower_bound and sort whenever applicable

// SPsPQ.h
//
// Base class for all special-purpose priority queues.
//
//


#ifndef SPSPQ_H
#define SPSPQ_H

#include <functional>  


template<typename T, typename Compare = std::less<T>>
class SPsPQ 
{
public: // INTERFACE
    
    // DTOR
    virtual ~SPsPQ() = default;

    // OPERATIONS
    virtual void push(const T& value) = 0;         
    virtual void pop() = 0;                        
    virtual const T& getTop() const = 0;                              
    virtual std::size_t getSize() const = 0;          
    virtual bool isEmpty() const = 0;
    virtual void updatePQ() = 0;             

protected: // MEMBERS
    
    // CTOR
    explicit SPsPQ(const Compare& comp = Compare())
        : compareFunctor{ comp } {}


    Compare compareFunctor;
}; // class SPsPQ

#endif // SPSPQ_H











#ifndef BIN_PQ_H
#define BIN_PQ_H

#include "SPsPQ.h"
#include <vector>


template <typename T, typename Compare = std::less<T>>
class BinPQ : public SPsPQ<T, Compare>
{

public:

    // Default constructor
    explicit BinPQ(const Compare &comp = Compare())
        : SPsPQ<T, Compare>(comp) {}


    // Range-based constructor
    template <typename Iterator>
    BinPQ(Iterator begin, Iterator end, 
            const Compare &comp = Compare())
        : SPsPQ<T, Compare>(comp), data(begin, end)
    { buildHeap(); }


    // Destructor (virtual, inherited from base)
    virtual ~BinPQ() = default;



    // Rebuild the heap when invariant is broken
    void updatePQ() override
    { 
        if (data.empty()) return;

        // Start from last non-leaf node and sift down each node
        size_t lastNonLeaf = (data.size() / 2) - 1;
        for (size_t i = lastNonLeaf; i < data.size(); ++i) 
            topDown(i); 
    } // updatePQ()



    // Push a new value into the queue
    void push(const T &value) override
    {
        data.push_back(value);
        // Sift up the new element 
        // to maintain heap property.
        bottomUp(data.size() - 1); 
    } // push()



    // Remove the top element
    void pop() override 
    {
        if (isEmpty())
            return;

        if (data.size() == 1)
        {
            data.pop_back();
            return;
        }

        // Move last element to root and sift down
        data[0] = data.back();
        data.pop_back();
        // Sift down from root to maintain heap property
        topDown(0); 
    } // pop()



    // Get the top element (highest priority)
    const T &getTop() const override
    {
        if (isEmpty())
            throw std::runtime_error("Priority queue is empty");
        return data[0]; // Root is always the top in a binary heap
    } // getTop()



    // Get the current size
    std::size_t getSize() const override
    { return data.size(); } 
    // getSize()


    // Check if the queue is empty
    bool isEmpty() const override
    { return data.empty(); } 
    // isEmpty()


private:

    std::vector<T> data; // Vector to store binary heap elements



    // Fix heap property top-down (sift down) when priority decreases at given index
    void topDown(std::size_t index) 
    {
        if (index >= data.size()) return;

        std::size_t size = data.size();
        while (true) 
        {
            std::size_t largest = index;
            std::size_t left = 2 * index + 1;
            std::size_t right = 2 * index + 2;

            // Check if left child exists and is better than current largest
            if (left < size && this->compareFunctor(data[largest], data[left])) {
                largest = left;
            }
            // Check if right child exists and is better than current largest
            if (right < size && this->compareFunctor(data[largest], data[right])) {
                largest = right;
            }

            // If largest is not the current index, swap and continue sifting down
            if (largest != index) {
                std::swap(data[index], data[largest]);
                index = largest;
            } else {
                break; // Heap property restored
            }
        }
    } // topDown()



    // Fix heap property bottom-up (sift up) when priority increases at given index
    void bottomUp(std::size_t index)
    {
        if (index >= data.size())
            return;

        // While not at root and parent is worse than current 
        std::size_t parent = (index - 1) / 2;
        while (index > 0 && this->compareFunctor(data[parent], data[index]))
        {
            std::swap(data[parent], data[index]);
            index = parent;
            parent = (index - 1) / 2;
        }
    } // bottomUp()


};

#endif // BIN_PQ_H

















CRIT:

Model A added a layer of redundancies by implementing the buildHeap method instead of updating the call to the nonexisting method to updatePQ, which is preferred. It is also using a 3rd party library that i must install. I do like the helpers it added and the move() utilization. 

Model B did not implement buildHeap. 


















P4.2:

combine statements whenever possible like the two returns in updatepq. also resolve the code duplicate and make copy/assignments more efficient. then update the edge tests to be compatible with my current test suite. take care to only include the tests that i dont currently have and add edge tests that are missing

// #include "MA_PQ.h"
#include "MB_PQ.h"
#include "UnorderedSPsPQ.h" 
#include "UnorderedFastSPsPQ.h"
// #include "BinPQ.h"
#include <vector>
#include <cassert>
#include <iostream>
#include <string>
#include <chrono>

using namespace std;





// 1. Create the functor via struct.
// Used to test a min-heap type priority queue containing doubles.
struct DescendingComp1
{
    // Prioritizes smaller doubles.
    bool operator()(double a, double b) const
    { return a > b; }
};

// 2. Create the functor via lambda.
// Used to test a min-heap type priority queue containing doubles.
// auto DescendingComp2 = [](double a, double b) 
// {
//     // Prioritizes smaller doubles.
//     return a > b;
// };

struct AbsComparator 
{
    bool operator()(double a, double b) const 
    { return fabs(a) < fabs(b); }
};

// Introduce "thresholded" comparisons, where small differences are treated as equal.
struct ThresholdComparator 
{
    bool operator()(double a, double b) const 
    {
        const double threshold = 0.01;
        return (fabs(a - b) > threshold) ? (a < b) : false;
    }
};




// Used to test a priority queue containing pointers to integers.
struct IntPtrComp
{
    // Prioritizes larger pointer ints.
    bool operator() (const int *a, const int *b) const
    { return *a < *b; }
};






// modify the pointer comp to work with hidden data!!!!!
// TODO: Make sure that you're using this->compare() properly, and everywhere
// that you should.  Complete this function by adding a functor that compares
// two HiddenData structures, create a PQ of the specified type, and call
// this function from main().
void testHiddenData(const string &pqType)
{
    // Complex comparisons: mulit-field objects.
    struct HiddenData
    {
        int data;
        double dec_data;
        HiddenData(int d) : data(d) {}
        HiddenData(double dec) : dec_data(dec) {}
    };

    
    // Basic max-heap functionality.
    struct HiddenDataMaxHeap
    {
        bool operator()(const HiddenData &a, const HiddenData &b) const
            { return (a.data < b.data); }
    };


    // Prioritize doubles with respect to absolute values.
    struct HDAbsComparator 
    {
        bool operator()(const HiddenData &a, const HiddenData &b) const 
        { return fabs(a.dec_data) < fabs(b.dec_data); }
    };


    
    struct OddFirstComp 
    {
        bool operator()(const HiddenData &a, const HiddenData &b) const 
        {
            if ((a.data % 2) != (b.data % 2)) 
            {
                return (a.data % 2) < (b.data % 2); 
            }
            return a.data < b.data; 
        }
    };


    // Prioritize integers with respect to absolute values.
    struct AbsValueComp 
    {
        bool operator()(const HiddenData &a, const HiddenData &b) const 
        { return std::abs(a.data) < std::abs(b.data); }
    };


    // Order by the last digit
    auto customComp = [](const HiddenData &a, const HiddenData &b) 
    { return (a.data % 10) < (b.data % 10); };

    
    cout << "\n\n********** START: Testing " << pqType << " with hidden data **********\n" << endl;
    
    // TODO: Add code here to actually test with the HiddenData type.

    /*
        I ESSENTIALLY HAVE TO DEFINE A CUSTOM COMPARATOR FOR THE "HIDDENDATA" CUSTOM TYPE. THIS WILL TEST AND VERIFY THAT THE PQ IMPLEMENTATION ALWAYS RESPECTS THE SPECIFIED COMPARATOR AND ALSO CORRECTLY IDENTIFIES THE MOST EXTREME ELEMENT ACCORDING TO THE COMPARATOR. IT MIGHT ALSO REVEAL ISSUES THAT DONT OCCUR WITH PRIMITIVE TYPES. 
    */

    // Would it make sense or be a good test to create a simple unordered pq w/ the hidden type and no custom comparator, or does that defeat the purpose?



    

    if (pqType == "Unordered")
    {
        // Create a simple sorted pq w/ the hidden type and comparator.
        UnorderedPQ<HiddenData, HiddenDataMaxHeap> pq;

        // Populate the pq
        pq.push(HiddenData(5));
        pq.push(HiddenData(10));
        pq.push(HiddenData(3));

        // Verify size and top element.
        assert(pq.getSize() == 3);
        assert(pq.getTop().data == 10);

        // Pop and check remaining elements
        pq.pop();
        assert(pq.getTop().data == 5);
        pq.pop();
        assert(pq.getTop().data == 3);
        pq.pop();
        assert(pq.isEmpty());

        UnorderedPQ<HiddenData, HDAbsComparator> pq2;
        pq2.push(HiddenData(-10.5));
        pq2.push(HiddenData(5.2));
        pq2.push(HiddenData(-3.3));

        assert(pq2.getTop().dec_data == -10.5); // Largest absolute decimal
        pq2.pop();
        assert(pq2.getTop().dec_data == 5.2);


        // Odds before evens:
        /**
         * Input: [4, 1, 3, 2]
         * Ordering:
         * 1. Odd numbers first: [1, 3, 4, 2]
         * 2. Within odd numbers, larger first: [3, 1, 4, 2]
         * 3. Within even numbers, larger first: [3, 1, 4, 2]
         * Final order: [3, 1, 4, 2]
         */
        UnorderedPQ<HiddenData, OddFirstComp> pq4;
        pq4.push(HiddenData(4));
        pq4.push(HiddenData(1));
        pq4.push(HiddenData(3));
        pq4.push(HiddenData(2));

        assert(pq4.getTop().data == 3); 
        pq4.pop();
        assert(pq4.getTop().data == 1);
        pq4.pop();
        pq4.pop();
        assert(pq4.getTop().data == 2);
        pq4.pop();
        assert(pq4.isEmpty());



        // Order by the last digit
        UnorderedPQ<HiddenData, decltype(customComp)> pqL(customComp);
        pqL.push(HiddenData(12));
        pqL.push(HiddenData(25));
        pqL.push(HiddenData(13));
        pqL.push(HiddenData(7));

        assert(pqL.getTop().data == 7);
        pqL.pop();
        assert(pqL.getTop().data == 25);
        pqL.pop();
        assert(pqL.getTop().data == 13);
        pqL.pop();
        assert(pqL.getTop().data == 12);
        pqL.pop();
        assert(pqL.isEmpty());
    }
    else if (pqType == "UnorderedOPT")
    {
        // Create a simple sorted pq w/ the hidden type and comparator.
        UnorderedPQOptimized<HiddenData, HiddenDataMaxHeap> pq;

        // Populate the pq
        pq.push(HiddenData(5));
        pq.push(HiddenData(10));
        pq.push(HiddenData(3));

        // Verify size and top element.
        assert(pq.getSize() == 3);
        assert(pq.getTop().data == 10);

        // Pop and check remaining elements
        pq.pop();
        assert(pq.getTop().data == 5);
        pq.pop();
        assert(pq.getTop().data == 3);
        pq.pop();
        assert(pq.isEmpty());

        UnorderedPQOptimized<HiddenData, HDAbsComparator> pq2;
        pq2.push(HiddenData(-10.5));
        pq2.push(HiddenData(5.2));
        pq2.push(HiddenData(-3.3));

        assert(pq2.getTop().dec_data == -10.5); // Largest absolute decimal
        pq2.pop();
        assert(pq2.getTop().dec_data == 5.2);


        // Odds before evens
        UnorderedPQOptimized<HiddenData, OddFirstComp> pq4;
        pq4.push(HiddenData(4));
        pq4.push(HiddenData(1));
        pq4.push(HiddenData(3));
        pq4.push(HiddenData(2));

        assert(pq4.getTop().data == 3); 
        pq4.pop();
        assert(pq4.getTop().data == 1);
        pq4.pop();
        pq4.pop();
        assert(pq4.getTop().data == 2);
        pq4.pop();
        assert(pq4.isEmpty());



        // Order by the last digit
        UnorderedPQOptimized<HiddenData, decltype(customComp)> pqL(customComp);
        pqL.push(HiddenData(12));
        pqL.push(HiddenData(25));
        pqL.push(HiddenData(13));
        pqL.push(HiddenData(7));

        assert(pqL.getTop().data == 7);
        pqL.pop();
        assert(pqL.getTop().data == 25);
        pqL.pop();
        assert(pqL.getTop().data == 13);
        pqL.pop();
        assert(pqL.getTop().data == 12);
        pqL.pop();
        assert(pqL.isEmpty());
    }
    else if (pqType == "Binary")
    {
        // Create a simple sorted pq w/ the hidden type and comparator.
        BinPQ<HiddenData, HiddenDataMaxHeap> pq;

        // Populate the pq
        pq.push(HiddenData(5));
        pq.push(HiddenData(10));
        pq.push(HiddenData(3));

        // Verify size and top element.
        assert(pq.getSize() == 3);
        assert(pq.getTop().data == 10);

        // Pop and check remaining elements
        pq.pop();
        assert(pq.getTop().data == 5);
        pq.pop();
        assert(pq.getTop().data == 3);
        pq.pop();
        assert(pq.isEmpty());

        BinPQ<HiddenData, HDAbsComparator> pq2;
        pq2.push(HiddenData(-10.5));
        pq2.push(HiddenData(5.2));
        pq2.push(HiddenData(-3.3));

        assert(pq2.getTop().dec_data == -10.5); // Largest absolute decimal
        pq2.pop();
        assert(pq2.getTop().dec_data == 5.2);


        // Odds before evens
        BinPQ<HiddenData, OddFirstComp> pq4;
        pq4.push(HiddenData(4));
        pq4.push(HiddenData(1));
        pq4.push(HiddenData(3));
        pq4.push(HiddenData(2));

        assert(pq4.getTop().data == 3); 
        pq4.pop();
        assert(pq4.getTop().data == 1);
        pq4.pop();
        pq4.pop();
        assert(pq4.getTop().data == 2);
        pq4.pop();
        assert(pq4.isEmpty());



        // Order by the last digit
        BinPQ<HiddenData, decltype(customComp)> pqL(customComp);
        pqL.push(HiddenData(12));
        pqL.push(HiddenData(25));
        pqL.push(HiddenData(13));
        pqL.push(HiddenData(7));

        assert(pqL.getTop().data == 7);
        pqL.pop();
        assert(pqL.getTop().data == 25);
        pqL.pop();
        assert(pqL.getTop().data == 13);
        pqL.pop();
        assert(pqL.getTop().data == 12);
        pqL.pop();
        assert(pqL.isEmpty());
    }


    cout << "\n\n********** END: Testing " << pqType << " with hidden data succeeded! **********\n" << endl;
   
} // testHiddenData()



// TODO: Add more code to this function to test if updatePriorities()
// is working properly.
void testUpdatePQHelper(SPsPQ<int *, IntPtrComp> *pq)
{
    vector<int> data;
    data.reserve(100);
    data.push_back(100);
    data.push_back(1);
    data.push_back(5);
    data.push_back(4);
    data.push_back(9);
    data.push_back(2);
    data.push_back(3);
    data.push_back(80);
    data.push_back(90);
    
    // NOTE: If you add more data to the vector, don't push the pointers
    // until AFTER the vector stops changing size!  Think about why.
    // You can add up to 100 values, or change the reserve if you want more.
    
    for (size_t i = 0; i < data.size(); ++i)
    {
        pq->push(&data[i]);
    } // for
    
    // Change the first value (which is pointed to by the pq), and check it.
    data[0] = 10;
    pq->updatePQ();
    assert(*pq->getTop() == 90);
    data[1] = 200;
    pq->updatePQ();
    assert(*pq->getTop() == 200);
    data[0] = 3000;
    pq->updatePQ();
    assert(*pq->getTop() == 3000);
    
} // testUpdatePQHelper()



// TODO: Add more code to this function to test if updatePriorities()
// is working properly.
void testUpdatePQ(const string &pqType)
{
    cout << "\n\n********** START: Testing " << pqType << " priority queue updatePQ() **********\n" << endl;

    SPsPQ<int *, IntPtrComp> *pq = nullptr;
    
    if (pqType == "Unordered")
    {
        pq = new UnorderedPQ<int *, IntPtrComp>;
    } // if
    else if (pqType == "UnorderedOPT")
    {
        pq = new UnorderedPQOptimized<int *, IntPtrComp>;
    }
    else if (pqType == "Binary")
    {
        pq = new BinPQ<int *, IntPtrComp>;
    } // else if

    // TODO: Add more types here inside 'else if' statements, like in main().
    
    if (!pq)
    {
        cout << "Invalid pq pointer; did you forget to create it?" << endl;
        return;
    } // if
    
    testUpdatePQHelper(pq);

    cout << "\n\n********** END: Testing " << pqType << " priority queue updatePQ() succeeded! **********\n" << endl;

    delete pq;
} // testUpdatePQ()



// Test the basic functionality of the priority queue pointer version.
void testPriorityQueuePtr(SPsPQ<int> *pq, const string &pqType)
{
    cout << "\n\n********** START: Testing " << pqType << " basic functionality (pointer version) **********\n" << endl;

    // Very basic testing.
    cout << "Test 1: integer values...\n"
         << endl;
    pq->push(3);
    pq->push(4);
    assert(pq->getSize() == 2);
    assert(pq->getTop() == 4);

    pq->pop();
    assert(pq->getSize() == 1);
    assert(pq->getTop() == 3);
    assert(!pq->isEmpty());

    pq->pop();
    assert(pq->getSize() == 0);
    assert(pq->isEmpty());

    pq->push(18);
    pq->push(81);
    pq->push(42);
    assert(pq->getTop() == 81);
    pq->pop();
    assert(pq->getTop() == 42);
    pq->pop();
    assert(pq->getTop() == 18);
    pq->pop();

    // Start fresh w/ an empty pq.
    assert(pq->isEmpty());

    cout << "Integer value tests passed!\n"
         << endl;

    // TODO: Add more testing here!

    // More focused unit testing.

    // Large range of values
    cout << "Testing with extrame values...\n"
         << endl;
    pq->push(INT_MIN);
    pq->push(INT_MAX);
    pq->push(0);
    pq->push(500);
    pq->push(-500);
    assert(pq->getSize() == 5);
    assert(pq->getTop() == INT_MAX);
    pq->pop();
    assert(pq->getTop() == 500);
    pq->pop();
    assert(pq->getTop() == 0);
    pq->pop();
    assert(pq->getTop() == -500);
    pq->pop();
    assert(pq->getTop() == INT_MIN);
    pq->pop();
    assert(pq->isEmpty());
    cout << "Extreme value tests passed!\n"
         << endl;

    // Sorted input
    cout << "Testing with sorted values...\n"
         << endl;
    for (int i = 1; i <= 10; ++i)
        pq->push(i);
    assert(pq->getSize() == 10);
    assert(pq->getTop() == 10);
    pq->pop();
    assert(pq->getTop() == 9);
    pq->pop();
    // Clean-up
    while (!pq->isEmpty())
        pq->pop();
    cout << "Sorted value tests passed!\n"
         << endl;

    // Reverse-sorted input
    cout << "Testing with reversed sorted values...\n"
         << endl;
    for (int i = 10; i >= 1; --i)
        pq->push(i);
    assert(pq->getSize() == 10);
    assert(pq->getTop() == 10);
    pq->pop();
    assert(pq->getTop() == 9);
    pq->pop();
    // Clean-up
    while (!pq->isEmpty())
        pq->pop();
    cout << "Reversed sorted value tests passed!\n"
         << endl;

    // Mix of positive and negative numbers
    cout << "Testing with both +/- values...\n"
         << endl;
    pq->push(-10);
    pq->push(50);
    pq->push(0);
    pq->push(-5);
    pq->push(30);
    assert(pq->getSize() == 5);
    assert(pq->getTop() == 50);
    pq->pop();
    assert(pq->getTop() == 30);
    pq->pop();
    assert(pq->getTop() == 0);
    pq->pop();
    assert(pq->getTop() == -5);
    pq->pop();
    assert(pq->getTop() == -10);
    pq->pop();
    cout << "Both +/- value tests passed!\n"
         << endl;

    // Testing `updatePriorities()` after manual data modification
    /*
        I.e., simulate a scenario where updatePriorities() is called explicitly and verify heap integrity afterward.
    */
    cout << "Testing by manually modifying the values...\n"
         << endl;
    pq->push(100);
    pq->push(200);
    pq->push(50);
    pq->push(75);
    // Simulate external modification
    pq->updatePQ();
    assert(pq->getTop() == 200);
    pq->pop();
    assert(pq->getTop() == 100);
    pq->pop();
    assert(pq->getTop() == 75);
    cout << "Manual value modification tests passed!\n"
         << endl;


    cout << "\n\n********** END: Testing " << pqType << " basic functionality (pointer version) succeeded! **********\n" << endl;
} // testPriorityQueuePtr()



// Test the unsorted heap's range-based constructor, copy constructor,
// and operator=().
//
void testPQsCtor(SPsPQ<int> *pq, const string &pqType)
{
    // Send a subset = {6,...,87}, i.e., shrink the range
    // by setting a ptr to the 6th elt and the the 11th
    // elt to get the subset [6, 45).

    cout << "\n\n********** START: Testing " << pqType << "'s range-based constructor **********\n" << endl;

    // Empty vector tests
    // cout << "Testing with an empty vector...\n"
    //      << endl;

    // std::vector<int> empty;
    // SPsPQ<int>* emptyPQ = new UnorderedPQ<int>(empty.begin(), empty.end());
    // assert(emptyPQ->isEmpty());
    // assert(emptyPQ->getSize() == 0);
    // assert(emptyPQ->getTop() == 0);
    // delete emptyPQ;

    assert(pq->getSize() == 6);
    assert(pq->getTop() == 87);

    pq->pop();
    assert(pq->getSize() == 5);
    assert(pq->getTop() == 65);
    assert(!pq->isEmpty());

    pq->pop();
    assert(pq->getSize() == 4);
    assert(!pq->isEmpty());

    // TODO: Add more testing here!

    cout << "\n\n********** END: Testing " << pqType << "'s range-based constructor succeeded! **********\n" << endl;
} // testPQsCtor()



// Test the basic functionality of the priority queue regular version.
void testPriorityQueue(const string &pqType) 
{
    cout << "\n\n********** START: Testing " << pqType << " basic functionality (regular version) **********\n" << endl;

    if (pqType == "Unordered")
    {
        // Test 1: Empty queue
        cout << "Test 1: empty queue..."
         << endl;
        UnorderedPQ<int> pq1;
        assert(pq1.isEmpty() && "Empty queue should report empty");
        try {
            pq1.getTop();
            std::cout << "Test 1 failed: Expected exception on empty getTop\n";
        } catch (const std::runtime_error&) {
            std::cout << "Test 1 passed: Empty queue throws on getTop\n";
        }

        // Test 2: Single element
        cout << "Test 2: single element..."
         << endl;
        pq1.push(42);
        assert(pq1.getSize() == 1 && "Size should be 1");
        assert(pq1.getTop() == 42 && "Top should be 42");
        pq1.pop();
        assert(pq1.isEmpty() && "Queue should be empty after pop");
        cout << "Test 2 passed!\n"
         << endl;

        // Test 3: Range-based constructor with duplicates
        cout << "Test 3: range-based constructor with duplicates..."
         << endl;
        int arr[] = {3, 1, 4, 1, 5, 9, 2, 6, 5};
        UnorderedPQ<int> pq2(arr, arr + 9);
        assert(pq2.getSize() == 9 && "Size should match range");
        assert(pq2.getTop() == 9 && "Top should be max (9)");
        pq2.pop();
        assert(pq2.getTop() == 6 && "Next top should be 6 after pop");
        cout << "Test 3 passed!\n"
         << endl;

        // Test 4: All equal elements
        cout << "Test 4: all equal elements..."
         << endl;
        UnorderedPQ<int> pq3;
        for (int i = 0; i < 5; ++i) pq3.push(7);
        assert(pq3.getSize() == 5 && "Size should be 5");
        assert(pq3.getTop() == 7 && "Top should be 7");
        pq3.pop();
        assert(pq3.getSize() == 4 && "Size should decrease");
        assert(pq3.getTop() == 7 && "Top should still be 7");
        cout << "Test 4 passed!\n"
         << endl;

        // Test 5: Push after pop to zero
        cout << "Test 5: push after pop to zero..."
         << endl;
        UnorderedPQ<int> pq4;
        pq4.push(1);
        pq4.pop();
        assert(pq4.isEmpty() && "Should be empty after pop");
        pq4.push(2);
        assert(pq4.getTop() == 2 && "New push should work");
        cout << "Test 5 passed!\n"
         << endl;

        // Test 6: Large number of elements
        cout << "Test 6: large number of elements..."
         << endl;
        UnorderedPQ<int> pq5;
        for (int i = 0; i < 1000; ++i) pq5.push(i);
        assert(pq5.getSize() == 1000 && "Size should be 1000");
        assert(pq5.getTop() == 999 && "Top should be max (999)");
        cout << "Test 6 passed!\n"
         << endl;

    }
    else if (pqType == "UnorderedOPT")
    {
        // Test 1: Empty queue
        cout << "Test 1: empty queue..."
         << endl;
        UnorderedPQOptimized<int> pq1;
        assert(pq1.isEmpty() && "Empty queue should report empty");
        try {
            pq1.getTop();
            std::cout << "Test 1 failed: Expected exception on empty getTop\n";
        } catch (const std::runtime_error&) {
            std::cout << "Test 1 passed: Empty queue throws on getTop\n";
        }

        // Test 2: Single element
        cout << "Test 2: single element..."
         << endl;
        pq1.push(42);
        assert(pq1.getSize() == 1 && "Size should be 1");
        assert(pq1.getTop() == 42 && "Top should be 42");
        pq1.pop();
        assert(pq1.isEmpty() && "Queue should be empty after pop");
        cout << "Test 2 passed!\n"
         << endl;

        // Test 3: Range-based constructor with duplicates
        cout << "Test 3: range-based constructor with duplicates..."
         << endl;
        int arr[] = {3, 1, 4, 1, 5, 9, 2, 6, 5};
        UnorderedPQOptimized<int> pq2(arr, arr + 9);
        assert(pq2.getSize() == 9 && "Size should match range");
        assert(pq2.getTop() == 9 && "Top should be max (9)");
        pq2.pop();
        assert(pq2.getTop() == 6 && "Next top should be 6 after pop");
        cout << "Test 3 passed!\n"
         << endl;

        // Test 4: All equal elements
        cout << "Test 4: all equal elements..."
         << endl;
        UnorderedPQOptimized<int> pq3;
        for (int i = 0; i < 5; ++i) pq3.push(7);
        assert(pq3.getSize() == 5 && "Size should be 5");
        assert(pq3.getTop() == 7 && "Top should be 7");
        pq3.pop();
        assert(pq3.getSize() == 4 && "Size should decrease");
        assert(pq3.getTop() == 7 && "Top should still be 7");
        cout << "Test 4 passed!\n"
         << endl;

        // Test 5: Push after pop to zero
        cout << "Test 5: push after pop to zero..."
         << endl;
        UnorderedPQOptimized<int> pq4;
        pq4.push(1);
        pq4.pop();
        assert(pq4.isEmpty() && "Should be empty after pop");
        pq4.push(2);
        assert(pq4.getTop() == 2 && "New push should work");
        cout << "Test 5 passed!\n"
         << endl;

        // Test 6: Large number of elements
        cout << "Test 6: large number of elements..."
         << endl;
        UnorderedPQOptimized<int> pq5;
        for (int i = 0; i < 1000; ++i) pq5.push(i);
        assert(pq5.getSize() == 1000 && "Size should be 1000");
        assert(pq5.getTop() == 999 && "Top should be max (999)");
        cout << "Test 6 passed!\n"
         << endl;
    }
    else if (pqType == "Binary")
    {
        // Test 1: Empty queue
        cout << "Test 1: empty queue..."
         << endl;
        BinPQ<int> pq1;
        assert(pq1.isEmpty() && "Empty queue should report empty");
        try {
            pq1.getTop();
            std::cout << "Test 1 failed: Expected exception on empty getTop\n";
        } catch (const std::runtime_error&) {
            std::cout << "Test 1 passed: Empty queue throws on getTop\n";
        }

        // Test 2: Single element
        cout << "Test 2: single element..."
         << endl;
        pq1.push(42);
        assert(pq1.getSize() == 1 && "Size should be 1");
        assert(pq1.getTop() == 42 && "Top should be 42");
        pq1.pop();
        assert(pq1.isEmpty() && "Queue should be empty after pop");
        cout << "Test 2 passed!\n"
         << endl;

        // Test 3: Range-based constructor with duplicates
        cout << "Test 3: range-based constructor with duplicates..."
         << endl;
        int arr[] = {3, 1, 4, 1, 5, 9, 2, 6, 5};
        BinPQ<int> pq2(arr, arr + 9);
        assert(pq2.getSize() == 9 && "Size should match range");
        assert(pq2.getTop() == 9 && "Top should be max (9)");
        pq2.pop();
        assert(pq2.getTop() == 6 && "Next top should be 6 after pop");
        cout << "Test 3 passed!\n"
         << endl;

        // Test 4: All equal elements
        cout << "Test 4: all equal elements..."
         << endl;
        BinPQ<int> pq3;
        for (int i = 0; i < 5; ++i) pq3.push(7);
        assert(pq3.getSize() == 5 && "Size should be 5");
        assert(pq3.getTop() == 7 && "Top should be 7");
        pq3.pop();
        assert(pq3.getSize() == 4 && "Size should decrease");
        assert(pq3.getTop() == 7 && "Top should still be 7");
        cout << "Test 4 passed!\n"
         << endl;

        // Test 5: Push after pop to zero
        cout << "Test 5: push after pop to zero..."
         << endl;
        BinPQ<int> pq4;
        pq4.push(1);
        pq4.pop();
        assert(pq4.isEmpty() && "Should be empty after pop");
        pq4.push(2);
        assert(pq4.getTop() == 2 && "New push should work");
        cout << "Test 5 passed!\n"
         << endl;

        // Test 6: Large number of elements
        cout << "Test 6: large number of elements..."
         << endl;
        BinPQ<int> pq5;
        for (int i = 0; i < 1000; ++i) pq5.push(i);
        assert(pq5.getSize() == 1000 && "Size should be 1000");
        assert(pq5.getTop() == 999 && "Top should be max (999)");
        cout << "Test 6 passed!\n"
         << endl;
    }

    cout << "\n\n********** END: Testing " << pqType << " basic functionality (regular version) succeeded! **********\n" << endl;
} // testPriorityQueue()



void runEdgeTests(const string &pqType) 
{
    cout << "\n\n********** START: Testing " << pqType << " edge tests to reveal version-specific bugs (regular version) **********\n" << endl;


    if (pqType == "Unordered")
    {
        // Test 1: Push-pop-push with equal elements
        {
            cout << "Test 1: Push-pop-push with equal elements\n";
            UnorderedPQ<int> pq;  // Replace with UnorderedPQOptimized for comparison
            pq.push(5);
            pq.push(5);  // Two equal max elements
            assert(pq.getTop() == 5 && "Top should be 5");
            pq.pop();    // Remove one 5
            assert(pq.getTop() == 5 && "Top should still be 5");
            pq.push(5);  // Add another 5
            assert(pq.getTop() == 5 && "Top should remain 5");
            cout << "Test 1 passed!\n"
             << endl;
        }
        // Potential Bug: In Optimized, if pop invalidates topIdx but doesn’t rescan correctly,
        // it might miss the remaining 5 or pick the wrong index after push.

        // Test 2: Pop all elements then push new max
        {
            std::cout << "Test 2: Pop all elements then push new max\n";
            UnorderedPQ<int> pq;
            pq.push(3);
            pq.push(4);
            pq.pop();  // Remove 4
            pq.pop();  // Remove 3
            assert(pq.isEmpty() && "Queue should be empty");
            pq.push(5);  // New max after empty
            assert(pq.getTop() == 5 && "Top should be 5");
            std::cout << "Test 2 passed\n";
        }
        // Potential Bug: Optimized might not reset topIdx properly after emptying,
        // causing getTop to reference an invalid index or old data.

        // Test 3: Push lower value after pop, check top
        {
            std::cout << "Test 3: Push lower value after pop\n";
            UnorderedPQ<int> pq;
            pq.push(10);
            pq.push(8);
            pq.pop();  // Remove 10
            assert(pq.getTop() == 8 && "Top should be 8");
            pq.push(5);  // Lower than current top
            assert(pq.getTop() == 8 && "Top should still be 8");
            std::cout << "Test 3 passed\n";
        }
        // Potential Bug: Optimized might incorrectly update topIdx to 5 during push,
        // assuming new elements always challenge the top.

        // Test 4: Repeated pop with duplicates
        {
            std::cout << "Test 4: Repeated pop with duplicates\n";
            UnorderedPQ<int> pq;
            pq.push(7);
            pq.push(7);
            pq.push(7);  // Three equal max elements
            pq.pop();    // Remove one 7
            assert(pq.getTop() == 7 && "Top should be 7");
            pq.pop();    // Remove another 7
            assert(pq.getTop() == 7 && "Top should still be 7");
            pq.pop();    // Remove last 7
            assert(pq.isEmpty() && "Queue should be empty");
            std::cout << "Test 4 passed\n";
        }
        // Potential Bug: Optimized might fail to find the next 7 if topIdx isn’t updated
        // after each pop, or it might not handle empty state correctly.

        // Test 5: Range init with all equal, pop all
        {
            std::cout << "Test 5: Range init with all equal, pop all\n";
            int arr[] = {4, 4, 4, 4};
            UnorderedPQ<int> pq(arr, arr + 4);
            assert(pq.getTop() == 4 && "Top should be 4");
            pq.pop();
            assert(pq.getTop() == 4 && "Top should be 4");
            pq.pop();
            pq.pop();
            pq.pop();
            assert(pq.isEmpty() && "Queue should be empty");
            std::cout << "Test 5 passed\n";
        }

    }
    else if (pqType == "UnorderedOPT")
    {
        std::cout << "Running edge tests on UnorderedPQOptimized to reveal version-specific bugs...\n";

        // Test 1: Push-pop-push with equal elements
        {
            std::cout << "Test 1: Push-pop-push with equal elements\n";
            UnorderedPQOptimized<int> pq;  // Replace with UnorderedPQOptimized for comparison
            pq.push(5);
            pq.push(5);  // Two equal max elements
            assert(pq.getTop() == 5 && "Top should be 5");
            pq.pop();    // Remove one 5
            assert(pq.getTop() == 5 && "Top should still be 5");
            pq.push(5);  // Add another 5
            assert(pq.getTop() == 5 && "Top should remain 5");
            std::cout << "Test 1 passed\n";
        }
        // Potential Bug: In Optimized, if pop invalidates topIdx but doesn’t rescan correctly,
        // it might miss the remaining 5 or pick the wrong index after push.

        // Test 2: Pop all elements then push new max
        {
            std::cout << "Test 2: Pop all elements then push new max\n";
            UnorderedPQOptimized<int> pq;
            pq.push(3);
            pq.push(4);
            pq.pop();  // Remove 4
            pq.pop();  // Remove 3
            assert(pq.isEmpty() && "Queue should be empty");
            pq.push(5);  // New max after empty
            assert(pq.getTop() == 5 && "Top should be 5");
            std::cout << "Test 2 passed\n";
        }
        // Potential Bug: Optimized might not reset topIdx properly after emptying,
        // causing getTop to reference an invalid index or old data.

        // Test 3: Push lower value after pop, check top
        {
            std::cout << "Test 3: Push lower value after pop\n";
            UnorderedPQOptimized<int> pq;
            pq.push(10);
            pq.push(8);
            pq.pop();  // Remove 10
            assert(pq.getTop() == 8 && "Top should be 8");
            pq.push(5);  // Lower than current top
            assert(pq.getTop() == 8 && "Top should still be 8");
            std::cout << "Test 3 passed\n";
        }
        // Potential Bug: Optimized might incorrectly update topIdx to 5 during push,
        // assuming new elements always challenge the top.

        // Test 4: Repeated pop with duplicates
        {
            std::cout << "Test 4: Repeated pop with duplicates\n";
            UnorderedPQOptimized<int> pq;
            pq.push(7);
            pq.push(7);
            pq.push(7);  // Three equal max elements
            pq.pop();    // Remove one 7
            assert(pq.getTop() == 7 && "Top should be 7");
            pq.pop();    // Remove another 7
            assert(pq.getTop() == 7 && "Top should still be 7");
            pq.pop();    // Remove last 7
            assert(pq.isEmpty() && "Queue should be empty");
            std::cout << "Test 4 passed\n";
        }
        // Potential Bug: Optimized might fail to find the next 7 if topIdx isn’t updated
        // after each pop, or it might not handle empty state correctly.

        // Test 5: Range init with all equal, pop all
        {
            std::cout << "Test 5: Range init with all equal, pop all\n";
            int arr[] = {4, 4, 4, 4};
            UnorderedPQOptimized<int> pq(arr, arr + 4);
            assert(pq.getTop() == 4 && "Top should be 4");
            pq.pop();
            assert(pq.getTop() == 4 && "Top should be 4");
            pq.pop();
            pq.pop();
            pq.pop();
            assert(pq.isEmpty() && "Queue should be empty");
            std::cout << "Test 5 passed\n";
        }

    }
    else if (pqType == "Binary")
    {
        // Test 1: Push-pop-push with equal elements
        {
            cout << "Test 1: Push-pop-push with equal elements\n";
            BinPQ<int> pq;  // Replace with UnorderedPQOptimized for comparison
            pq.push(5);
            pq.push(5);  // Two equal max elements
            assert(pq.getTop() == 5 && "Top should be 5");
            pq.pop();    // Remove one 5
            assert(pq.getTop() == 5 && "Top should still be 5");
            pq.push(5);  // Add another 5
            assert(pq.getTop() == 5 && "Top should remain 5");
            cout << "Test 1 passed!\n"
             << endl;
        }
        // Potential Bug: In Optimized, if pop invalidates topIdx but doesn’t rescan correctly,
        // it might miss the remaining 5 or pick the wrong index after push.

        // Test 2: Pop all elements then push new max
        {
            std::cout << "Test 2: Pop all elements then push new max\n";
            BinPQ<int> pq;
            pq.push(3);
            pq.push(4);
            pq.pop();  // Remove 4
            pq.pop();  // Remove 3
            assert(pq.isEmpty() && "Queue should be empty");
            pq.push(5);  // New max after empty
            assert(pq.getTop() == 5 && "Top should be 5");
            std::cout << "Test 2 passed\n";
        }
        // Potential Bug: Optimized might not reset topIdx properly after emptying,
        // causing getTop to reference an invalid index or old data.

        // Test 3: Push lower value after pop, check top
        {
            std::cout << "Test 3: Push lower value after pop\n";
            BinPQ<int> pq;
            pq.push(10);
            pq.push(8);
            pq.pop();  // Remove 10
            assert(pq.getTop() == 8 && "Top should be 8");
            pq.push(5);  // Lower than current top
            assert(pq.getTop() == 8 && "Top should still be 8");
            std::cout << "Test 3 passed\n";
        }
        // Potential Bug: Optimized might incorrectly update topIdx to 5 during push,
        // assuming new elements always challenge the top.

        // Test 4: Repeated pop with duplicates
        {
            std::cout << "Test 4: Repeated pop with duplicates\n";
            BinPQ<int> pq;
            pq.push(7);
            pq.push(7);
            pq.push(7);  // Three equal max elements
            pq.pop();    // Remove one 7
            assert(pq.getTop() == 7 && "Top should be 7");
            pq.pop();    // Remove another 7
            assert(pq.getTop() == 7 && "Top should still be 7");
            pq.pop();    // Remove last 7
            assert(pq.isEmpty() && "Queue should be empty");
            std::cout << "Test 4 passed\n";
        }
        // Potential Bug: Optimized might fail to find the next 7 if topIdx isn’t updated
        // after each pop, or it might not handle empty state correctly.

        // Test 5: Range init with all equal, pop all
        {
            std::cout << "Test 5: Range init with all equal, pop all\n";
            int arr[] = {4, 4, 4, 4};
            BinPQ<int> pq(arr, arr + 4);
            assert(pq.getTop() == 4 && "Top should be 4");
            pq.pop();
            assert(pq.getTop() == 4 && "Top should be 4");
            pq.pop();
            pq.pop();
            pq.pop();
            assert(pq.isEmpty() && "Queue should be empty");
            std::cout << "Test 5 passed\n";
        }

    }

    cout << "\n\n********** END: Testing " << pqType << " edge tests to reveal version-specific bugs (regular version) succeeded! **********\n" << endl;

} // runEdgeTests()



void specialTests(const string &pqType)
{
    cout << "\n\n********** START: Testing " << pqType << "'s equal elements corner case **********\n" << endl;


    // Custom comparator that treats equal values differently based on position
    struct PositionAwareCompare 
    {
        bool operator()(const std::pair<int, int>& a, const std::pair<int, int>& b) const {
            // First compare values
            if (a.first != b.first) return a.first < b.first;
            // For equal values, prefer later positions (higher second value)
            return a.second < b.second;
        }
    };


    if (pqType == "Unordered")
    {
        // Create PQ with position-aware comparator
        UnorderedPQ<std::pair<int, int>, PositionAwareCompare> pq;
        
        // Push elements with same value but different positions
        pq.push({10, 1});  // Value 10, position 1
        assert(pq.getTop() == std::make_pair(10, 1) && "First element should be top");
        
        pq.push({10, 2});  // Value 10, position 2
        // BUG: Should select position 2 as top since it's "greater" with equal values
        // But the implementation only updates topIdx when strictly greater
        assert(pq.getTop() == std::make_pair(10, 2) && "Second element should be top");
        
        std::cout << "Test " << (pq.getTop().second == 2 ? "passed" : "FAILED") << "\n";
    }
    else if (pqType == "UnorderedOPT")
    {
        

        // Create PQ with position-aware comparator
        UnorderedPQOptimized<std::pair<int, int>, PositionAwareCompare> pq;
        
        // Push elements with same value but different positions
        pq.push({10, 1});  // Value 10, position 1
        assert(pq.getTop() == std::make_pair(10, 1) && "First element should be top");
        
        pq.push({10, 2});  // Value 10, position 2
        // BUG: Should select position 2 as top since it's "greater" with equal values
        // But the implementation only updates topIdx when strictly greater
        assert(pq.getTop() == std::make_pair(10, 2) && "Second element should be top");
        
        std::cout << "Test " << (pq.getTop().second == 2 ? "passed" : "FAILED") << "\n";
    }
    else if (pqType == "Binary")
    {
        

        // Create PQ with position-aware comparator
        BinPQ<std::pair<int, int>, PositionAwareCompare> pq;
        
        // Push elements with same value but different positions
        pq.push({10, 1});  // Value 10, position 1
        assert(pq.getTop() == std::make_pair(10, 1) && "First element should be top");
        
        pq.push({10, 2});  // Value 10, position 2
        // BUG: Should select position 2 as top since it's "greater" with equal values
        // But the implementation only updates topIdx when strictly greater
        assert(pq.getTop() == std::make_pair(10, 2) && "Second element should be top");
        
        std::cout << "Test " << (pq.getTop().second == 2 ? "passed" : "FAILED") << "\n";
    }

    cout << "\n\n********** END: Testing " << pqType << "'s equal elements corner case succeeded! **********\n" << endl;
} // specialTests()



void specialTests2(const string &pqType)
{
    cout << "\n\n********** START: Testing " << pqType << " special tests to reveal version-specific bugs **********\n" << endl;

    if (pqType == "Unordered")
    {
        UnorderedPQ<int> pq;
        pq.push(10);
        pq.push(20);
        pq.pop();  // Remove 20
        pq.push(5);  // Push smaller value
        assert(pq.getTop() == 10);  // This might fail if the bug exists
    }
    else if (pqType == "UnorderedOPT")
    {
        UnorderedPQOptimized<int> pq;
        pq.push(10);
        pq.push(20);
        pq.pop();  // Remove 20
        pq.push(5);  // Push smaller value
        assert(pq.getTop() == 10);  // This might fail if the bug exists

        UnorderedPQOptimized<int> pq2;
        pq2.push(10);
        pq2.push(5);
        pq2.pop();  // Remove 10
        pq2.push(4);  // Push smaller value
        assert(pq2.getTop() == 5);  // This might fail if the bug exists
    }
    else if (pqType == "Binary")
    {
        BinPQ<int> pq;
        pq.push(10);
        pq.push(20);
        pq.pop();  // Remove 20
        pq.push(5);  // Push smaller value
        assert(pq.getTop() == 10);  // This might fail if the bug exists

        BinPQ<int> pq2;
        pq2.push(10);
        pq2.push(5);
        pq2.pop();  // Remove 10
        pq2.push(4);  // Push smaller value
        assert(pq2.getTop() == 5);  // This might fail if the bug exists
    }

    cout << "\n\n********** END: Testing " << pqType << " special tests to reveal version-specific bugs succeeded! **********\n" << endl;
} // specialTests2()



int binTests() 
{
    cout << "\n\n********** START: Testing BinaryPQ **********\n" << endl;

    // Test 1: Basic operations with default constructor
    BinPQ<int> pq1;
    pq1.push(10);
    pq1.push(20);
    pq1.push(5);
    std::cout << "Test 1 - Top after pushes (5,10,20): " << pq1.getTop() << std::endl; // Should be 20
    assert(pq1.getTop() == 20);
    pq1.pop();
    std::cout << "Test 1 - Top after pop: " << pq1.getTop() << std::endl; // Should be 10
    assert(pq1.getTop() == 10);


    // Test 2: Range-based constructor
    std::vector<int> vec = {5, 2, 8, 1, 9, 3};
    BinPQ<int> pq2(vec.begin(), vec.end());
    std::cout << "Test 2 - Top from range (5,2,8,1,9,3): " << pq2.getTop() << std::endl; // Should be 9
    assert(pq2.getTop() == 9);


    // Test 3: bottomUp (priority increase simulation)
    BinPQ<int> pq3;
    pq3.push(10);
    pq3.push(20);
    pq3.push(5);
    // Simulate priority increase at index 2 (value 5 to something larger, say 25)
    pq3.push(25); // Adds at index 3, but for simulation, assume we modify index 2
    // In a real scenario, you'd modify data directly if priorities change, but for test, push and adjust
    std::cout << "Test 3 - Top before bottomUp: " << pq3.getTop() << std::endl; // Should be 25 or 20
    assert(pq3.getTop() == 25);
    // Note: For a real test, modify data[2] directly if priority changes


    // Test 4: topDown (priority decrease simulation)
    BinPQ<int> pq4;
    pq4.push(30);
    pq4.push(20);
    pq4.push(10);
    // Simulate priority decrease at root (index 0, value 30 to 5)
    // In real usage, you'd modify data[0] = 5, then call topDown(0)
    std::cout << "Test 4 - Top before topDown: " << pq4.getTop() << std::endl; // Should be 30
    assert(pq4.getTop() == 30);
    // Assume data[0] = 5; then call pq4.topDown(0); top should become 20
    // For simplicity, just pop and push to simulate
    pq4.pop();
    pq4.push(5);
    std::cout << "Test 4 - Top after simulated decrease: " << pq4.getTop() << std::endl; // Should be 20
    assert(pq4.getTop() == 20);


    // Test 5: updatePQ (rebuild heap)
    BinPQ<int> pq5;
    pq5.push(10);
    pq5.push(5);
    pq5.push(20);
    pq5.updatePQ(); // Rebuild heap, should still have 20 as top
    std::cout << "Test 5 - Top after updatePQ: " << pq5.getTop() << std::endl; // Should be 20
    assert(pq5.getTop() == 20);

    cout << "\n\n********** END: Testing BinaryPQ **********\n" << endl;

    return 0;
} // binTests()



int main()
{
    // Basic pointer, allocate a new PQ later based on user choice.
    SPsPQ<int> *pq1;
    SPsPQ<int> *pq2;
    vector<string> types{
        "Unordered",
        "UnorderedOPT",
        "Sorted",
        "Binary",
        "Pairing",
    }; // choice types

    
    unsigned int choice;
    cout << "PQ tester" << endl
         << endl;
    for (size_t i = 0; i < types.size(); ++i)
        cout << "  " << i << ") " << types[i] << endl;
    cout << endl;
    cout << "Select one {0-5}: ";
    cin >> choice;
    
    // Send a subset = {6,...,87}, i.e., shrink the range
    // by setting a ptr to the 6th elt and the the 11th
    // elt to get the subset [6, 45).
    vector<int> tester = {1, 2, 3, 8, 7, 6, 13, 42, 65, 43, 87, 45, 56, 35, 29};
    auto start = tester.begin() + 5;
    auto end = tester.begin() + 11;

    if (choice == 0)
    {
        // Test using the default comparator,
        // which organizes in ascending order.
        pq1 = new UnorderedPQ<int>;
        pq2 = new UnorderedPQ<int>(start, end);

    } // if
    else if (choice == 1)
    {
        pq1 = new UnorderedPQOptimized<int>;
        pq2 = new UnorderedPQOptimized<int>(start, end);
    }
    else if (choice == 3)
    {
        binTests();
        pq1 = new BinPQ<int>;
        pq2 = new BinPQ<int>(start, end);
    }
    else
    {
        cout << "Unknown container!" << endl
             << endl;
        exit(1);
    } // else

    // Send the pq.
    testPriorityQueue(types[choice]);
    testPriorityQueuePtr(pq1, types[choice]);
    testPQsCtor(pq2, types[choice]);

    testUpdatePQ(types[choice]);

    testHiddenData(types[choice]);
    
    runEdgeTests(types[choice]);

    specialTests(types[choice]);

    specialTests2(types[choice]);

    // Clean up!
    delete pq1;
    delete pq2;

    cout << "\n\n********** ALL TESTS PASSED! **********\n" << endl;

    return 0;
} // main()





















CRIT:

Model A still missed some code dupe!

Model B missed more!!!










P4.3:

u missed several code duplicate lines. make sure the code is consistent eg why use data.size when we have a member function???? also make the updatepq func more readable by adding the nonleaf variable back in there.










CRIT:

MA is better.


















P4.4:

implement a derived class that declares and defines a sorted pq that has the highest priority elt at the back such that traversing via it is in sorted order. also generate test cases in the same format as before that tests all the basic functionality of this new class.








CRIT:

Within push(), MA calls findInsertPosition, which takes a redundant step when it converts the iterator to a position and then back to an it. It also doesnt use the member functions when appropriate, e.g., rangebased should call updatePQ()!

MB's is perfect and provides a useful testing tool "at()".















P4.5:

whats the diff between using lower bound and upper bound for this implemnt?





CRIT:

But doesnt that contradict the sorted pq fifo behavior? 


In our priority queue context:

lower_bound maintains stability (equal elements stay in insertion order)

upper_bound would group equal elements together

For a priority queue, lower_bound is actually more appropriate because:

It maintains the relative order of equal-priority elements
It's more consistent with how priority queues typically 
behave

It's what we want when we say "find the first element that has higher priority"

That's why the current implementation using lower_bound is correct for a priority queue. Using upper_bound would change the behavior in subtle ways that might not be what users expect from a priority queue.





















































P5.1:

i am working on a sorte pq implement which is based on the SPsPQ interface and is one pq version i am interested in and will experiment with where my projects goal is to implement, experiment with, and pick out my own version of a pq (eg binary, sorted, etc) container that will eventually drive a stock market simulator however, i dont want to trivialize the implement of the pq operations by using pq prebaked functions like priority_queue<>, partial_sort(), sort_heap() etc. i dont want to use smart pointers either. but i am however using the stl for lower level vector operations since i am mostly interested in the PQ mechanics. i forgot to comment and document the sorted version, can u do that for me and make sure that it is in the same format and style as the binary version? note that most functions and the class is documented up top and whenever i use stl methods i also comment a note on their functionality. Then, can you add a function that i missed, ie, i need a "print()" function to display the entire heap for testing. and finally formulate a self contained corner case test function for sorted that will test the updatePQ method by filling up the container via push, modify/corrupt some values manually, call updatePQ and check that the top and pop values are correct. 






// SPsPQ.h
//
// Base class for all special-purpose priority queues.
//
//


#ifndef SPSPQ_H
#define SPSPQ_H

#include <functional>  


template<typename T, typename Compare = std::less<T>>
class SPsPQ 
{
public: // INTERFACE
    
    // DTOR
    virtual ~SPsPQ() = default;

    // OPERATIONS
    virtual void push(const T& value) = 0;         
    virtual void pop() = 0;                        
    virtual const T& getTop() const = 0;                              
    virtual std::size_t getSize() const = 0;          
    virtual bool isEmpty() const = 0;
    virtual void updatePQ() = 0;             

protected: // MEMBERS
    
    // CTOR
    explicit SPsPQ(const Compare& comp = Compare())
        : compareFunctor{ comp } {}


    Compare compareFunctor;
}; // class SPsPQ

#endif // SPSPQ_H









#ifndef BIN_PQ_H
#define BIN_PQ_H

#include "SPsPQ.h"
#include <vector>

/// @brief A binary heap implementation of a priority queue.
/// @tparam T: The type of the elements in the queue.
/// @tparam Compare: The comparison functor to use for the priority queue.
/// @note This implementation uses a vector to store the elements, and 
///       a heap property to maintain the order of the elements.
///       The heap property is maintained by the topDown() and bottomUp() 
///       functions.
template <typename T, typename Compare = std::less<T>>
class BinPQ : public SPsPQ<T, Compare>
{
    using BaseClass = SPsPQ<T, Compare>;

public:

    // Default constructor
    explicit BinPQ(const Compare &comp = Compare())
        : BaseClass(comp) 
    {}
    // DEFAULT CTOR


    // Range-based constructor
    template <typename Iterator>
    BinPQ(Iterator begin, Iterator end, 
        const Compare &comp = Compare())
            : BaseClass(comp), data(begin, end) 
    { updatePQ(); }
    // R-B CTOR


    // Copy constructor
    BinPQ(const BinPQ& other) 
        : BaseClass(other), 
        data(other.data) 
    {}
    // COPY CTOR


    // Move constructor
    BinPQ(BinPQ&& other) noexcept
        : BaseClass(
            std::move(other)),      // move the entire base class
        data(std::move(other.data)) // move the derived class's vector
    {}
    // MOVE CTOR


    // Copy assignment
    BinPQ& operator=(const BinPQ& other) 
    {
        if (this != &other) 
        {
            // Call the base class's assignment operator,
            // then assign the derived class's vector.
            BaseClass::operator=(other);
            data = other.data;
        }

        // Return the current BinPQ object.
        return *this;
    } // COPY ASSIGNMENT


    // Move assignment
    BinPQ& operator=(BinPQ&& other) noexcept 
    {
        if (this != &other) 
        {
            BaseClass::operator=(std::move(other));
            data = std::move(other.data);
        }

        return *this;
    } // MOVE ASSIGNMENT


    // Destructor
    virtual ~BinPQ() = default;


    /// @brief Update the priority queue to maintain the heap property.
    /// @note This function uses a post-decrement approach to overcome 
    ///       unsigned integer overflow and the use of static_cast. 
    ///       Read more about it in the notes!
    void updatePQ() override
    { 
        if (getSize() <= 1) return;

        // Start from last non-leaf node and sift down each node
        const size_t lastParentIdx = getParentIndex(getSize() - 1);
        for (size_t i = (lastParentIdx + 1); i-- > ROOT;)
            topDown(i); 
    } // updatePQ()



    /// @brief Push a new value into the queue, and call 
    ///        bottomUp() to maintain the heap property 
    ///        by bubbling up the new element.
    /// @param value: The value to push into the queue.
    void push(const T &value) override
    {
        data.push_back(value);
        bottomUp(getSize() - 1); 
    } // push()



    /// @brief Remove the top element, and call topDown() 
    ///        to maintain the heap property by sifting down 
    ///        the new root.
    void pop() override 
    {
        if (isEmpty()) return;
        data[ROOT] = std::move(data.back());
        data.pop_back();
        if (!isEmpty()) topDown(ROOT); 
    } // pop()



    /// @brief Get the top element (highest priority)
    /// @return The top element of the queue.
    const T &getTop() const override
    {
        if (isEmpty())
            throw std::runtime_error("Priority queue is empty");
        return data[ROOT]; // Root is always the top in a binary heap
    } // getTop()



    /// @brief Get the current size
    /// @return The current size of the queue.
    size_t getSize() const override { 
        return data.size(); 
    } // getSize()


    /// @brief Check if the queue is empty
    /// @return True if the queue is empty, false otherwise.
    bool isEmpty() const override { 
        return data.empty(); 
    } // isEmpty()


private:

    /// @brief Constants 
    static constexpr size_t ROOT = 0;
    static constexpr size_t NUM_CHILDREN = 2;
    
    /// @brief Heap container
    std::vector<T> data;


    /// @brief Helper to calculate parent index
    /// @param index: The index of the node to get the parent of.
    /// @return The index of the parent of the node at index.
    size_t getParentIndex(size_t index) const {
        return (index - 1) / NUM_CHILDREN;
    } // getParentIndex()


    /// @brief Helper to calculate left child index
    /// @param index: The index of the node to get the left child of.
    /// @return The index of the left child of the node at index.
    size_t getLeftChildIndex(size_t index) const {
        return NUM_CHILDREN * index + 1;
    } // getLeftChildIndex()


    /// @brief Helper to calculate right child index  
    /// @param index: The index of the node to get the right child of.
    /// @return The index of the right child of the node at index.
    size_t getRightChildIndex(size_t index) const {
        return NUM_CHILDREN * index + NUM_CHILDREN;
    } // getRightChildIndex()


    /// @brief Helper to check if compareFunctor says a < b 
    ///         (a has lower priority than b)
    /// @param a: The first element to compare.
    /// @param b: The second element to compare.
    /// @return True if a has lower priority than b, false otherwise.
    bool hasLowerPriority(const T& a, const T& b) const {
        return this->compareFunctor(a, b);
    } // hasLowerPriority()



    /// @brief Fix heap property top-down (fix down) when 
    ///         priority decreases at given index.
    /// @param index: The index of the node to sift down.
    void topDown(size_t index) 
    {
        const size_t size = getSize();
        while (true) 
        {
            size_t largest = index;
            const size_t left = getLeftChildIndex(index);
            const size_t right = getRightChildIndex(index);

            // Check if children exist, and if so, grab the larger one.
            // Then check if it is larger than the current largest, i.e., the parent.
            if (left < size && hasLowerPriority(data[largest], data[left])) 
                largest = left;
            
            if (right < size && hasLowerPriority(data[largest], data[right])) 
                largest = right;
            

            // If largest is not the current index, swap and continue sifting down
            if (largest != index) {
                std::swap(data[index], data[largest]);
                index = largest;
            } else {
                break; // Heap property restored
            }
        }
    } // topDown()



    /// @brief Fix heap property bottom-up (fix up) when 
    ///         priority increases at given index.
    /// @param index: The index of the node to sift up.
    void bottomUp(size_t index)
    {
        // While not at root, check if the parent is 
        // lower priority than the current node.
        while (index > ROOT)
        {
            const size_t parent = getParentIndex(index);
            if (hasLowerPriority(data[parent], data[index]))
            {
                std::swap(data[parent], data[index]);
                index = parent; // move up to the parent
            } else {
                break; // Heap property restored
            }
        }
    } // bottomUp()


}; // class BinPQ

#endif // BIN_PQ_H














#ifndef SORTED_PQ_H
#define SORTED_PQ_H

#include "SPsPQ.h"
#include <vector>
#include <algorithm>
#include <stdexcept>

template <typename T, typename Compare = std::less<T>>
class SortedPQ : public SPsPQ<T, Compare>
{

public:

    
    explicit SortedPQ(const Compare &comp = Compare())
        : SPsPQ<T, Compare>(comp) {}


    
    template <typename Iterator>
    SortedPQ(Iterator begin, Iterator end, const Compare &comp = Compare())
        : SPsPQ<T, Compare>(comp), data(begin, end) {
        updatePQ();
    }


    
    SortedPQ(const SortedPQ& other) 
        : SPsPQ<T, Compare>(other), data(other.data) {}

    
    SortedPQ(SortedPQ&& other) noexcept
        : SPsPQ<T, Compare>(std::move(other)), data(std::move(other.data)) {}

    
    SortedPQ& operator=(const SortedPQ& other) {
        if (this != &other) {
            SPsPQ<T, Compare>::operator=(other);
            data = other.data;
        }
        return *this;
    }

    
    SortedPQ& operator=(SortedPQ&& other) noexcept {
        if (this != &other) {
            SPsPQ<T, Compare>::operator=(std::move(other));
            data = std::move(other.data);
        }
        return *this;
    }



    virtual ~SortedPQ() = default;



    void push(const T &value) override 
    {
        auto pos = lower_bound(
            data.begin(), 
            data.end(), 
            value, 
            this->compareFunctor
        );

        data.insert(pos, value);
    }



    void pop() override {
        if (!isEmpty()) {
            data.pop_back(); 
        }
    }



    const T &getTop() const override {
        if (isEmpty())
            throw runtime_error("Priority queue is empty");
        return data.back(); 
    }



    size_t getSize() const override { 
        return data.size(); 
    } 


    bool isEmpty() const override { 
        return data.empty(); 
    }


    void updatePQ() override {
        if (getSize() <= 1) return;
        std::sort(data.begin(), data.end(), this->compareFunctor);
    }


    
    const T& at(std::size_t index) const {
        if (index >= getSize())
            throw std::out_of_range("Index out of range");
        return data[index];
    }

private:

    std::vector<T> data;
};

#endif 













CRIT:

both models are mixing up minheap and maxheap in the testSortedPQUpdate function! 



























P5.2:

the test case creates a sorted pq with the greater comparator, but then treats it as a max heap, which is incorrect. resolve that then generate a derived class that defines a pairing heap and implement it to produce a pairing pq. 











CRIT2:

theyre both good regarding the test case.

MA has a typo:
if (node->nextS sibling) {
    std::cout << ", ";
    printTree(node->nextSibling, prefix);
}
in the if-statment. after fixed, the usual errors arise. 









CRIT1:

MA needs a "T &getElt() const { return elt; }" and a "const T &operator*() const { return elt; }" functions for the node class. Its pq segfaults on lines 464-473 in MA_PQ.h. For MA, in its meld, whats the pupose of setting a->c->p = null if its originally not null? Why reset?

eg:
if (a->firstChild != nullptr) {
    a->firstChild->parent = nullptr; // Will be reset below
}

This block triggered when we pushed the 4th element '3' and it caused three's sibling '5' to sever the parent ptr and set it to null, but in my version, that doesnt happen and five's parent is the root '8'.



Both fail on this:

while (!pq.isEmpty()) {
    actual.push_back(pq.getTop());
    pq.pop();
}

and both have the RED within meld/merge of the 2nd if statement. a newNode will never be null, will it?

Which model is OVERALL better? 

They both pass all tests, but I like B better. 













P5.3:

I am constrained on memeory. is this pq implement version good on memory? also when, or what scenario will cause the 2nd if to execute within the merge? also, no smart ptrs, but regular ptrs are allowed and prefered. change the class to be ptr-based and simplify the node the member names stored to simply child, sibling, and prev. 










CRIT:

MA is better
















P5.4:

having two sizes is bit confusing, change the node member to numNodes. then add two functions to make the pq a true pairing heap: updateValue, which should update the priority of a node already in the heap by replacing the element refered to by the Node with newValue. it muust maintain pairing heap invariants and the new priority, 'newValue' must be more extreme as defined by comp than the old priority. then implement addNode, which should add a new element to the pairing heap then returns a Node* corresponding to the newly added element.









CRIT:

MA GOT IT.


























P6.1:

I just implementd the follwng pairing heap but i am not getting the right results. i dont use any methods that trivialize the heap operations but i will use other facilities. 




#ifndef PAIRINGPQ_H
#define PAIRINGPQ_H

#include "SPsPQ.h"
#include <deque>
#include <utility>
#include <iostream>

using namespace std;


///       Uses raw pointers for memory efficiency.
template <typename T, typename Compare = std::less<T>>
class PairingPQ : public SPsPQ<T, Compare>
{
    using BaseClass = SPsPQ<T, Compare>;
    
public:
    
    // Each node within the pairing heap
    class Node
    {

    public:
        
        // Node ctor
        explicit Node(const T &val)
        : elt{ val }, child{ nullptr }, sibling{ nullptr }, parent{ nullptr }
        {}
        
        const T &getElt() const { return elt; }
        const T &operator*() const { return elt; }
        
        friend PairingPQ;
        

    private:

        T elt;
        Node *child;
        Node *sibling;
        Node *parent;
        
    }; // class Node
    
    
    explicit PairingPQ(const Compare &comp = Compare()) :
    BaseClass{ comp }, root{ nullptr }, numNodes{ 0 }
    {} // DEFAULT CTOR
    
    
    template<typename InputIterator>
    PairingPQ(InputIterator start, InputIterator end,
              const Compare &comp = Compare()) :
    BaseClass{ comp }, root{ nullptr }, numNodes{ 0 }
    {
        while (start != end)
        {
            push(*start);
            start++;
        }
        
    } // R-B CTOR
    
    
    PairingPQ(const PairingPQ &other) :
    BaseClass{ other.compareFunctor }, root{ nullptr }, numNodes{ 0 }
    {
        if (other.root)
        {    // make a deque and insert root to other
            std::deque<Node*> dq;
            dq.push_back(other.root);
            
            while (!dq.empty())
            {
                // get the next element
                Node *ptr = traversalHelper(dq);
                
                // I now have the current node's child and sibling in the deck
                // waiting to get pushed. I push the current node first.
                push(ptr->elt);
            }
        }
        
    } // COPY CTOR
    
    
    PairingPQ &operator=(const PairingPQ &rhs)
    {
        // copy-swap method (idiot check not needed from now on)
        
        // use copy ctor to create a copy of the refrenced object on rhs
        PairingPQ temp(rhs);
        
        // begin swapping the temp's members with the current object's (lhs) members to get lhs = rhs.
        std::swap(temp.numNodes, numNodes);
        std::swap(temp.root, root);
        
        // temp is now destroyed once it goes out-of-scope.
        return *this;
        
    } // operator=()



    // Move constructor  
    PairingPQ(PairingPQ&& other) noexcept
        : BaseClass(std::move(other)), 
          root(other.root),
          numNodes(other.numNodes) 
    {
        other.root = nullptr;
        other.numNodes = 0;
    }
    // MOVE CTOR



    Node *traversalHelper(std::deque<Node*> &dq)
    {
        // Get the starting point and pop it.
        Node *ptr = dq.front();
        dq.pop_front();
            
        // Add the child and sibling if their not null.
        if (ptr->sibling)
            dq.push_back(ptr->sibling);
        if (ptr->child)
            dq.push_back(ptr->child);

        return ptr;
    } // traversalHelper()




    ~PairingPQ()
    {
        // make a deque and insert root
        std::deque<Node*> dq;
        
        if (!root)
            return;
        
        dq.push_back(root);
        
        while (!dq.empty())
        {
            // get the next element
            Node *ptr = traversalHelper(dq);
            
            // delete the current node
            delete ptr;
        }
        
        numNodes = 0;
        
    } // ~PairingPQ()




    
    virtual void updatePQ()
    {
        // create an aux deck
        std::deque<Node*> dq;
        dq.push_back(root->child);
        root->child = nullptr;
        
        // while not empty we take something out
        while (!dq.empty())
        {
            // get a starting point
            Node *ptr = traversalHelper(dq);
            
            // sever the relationship
            ptr->parent = nullptr;
            //ptr->child = nullptr;
            ptr->sibling = nullptr;
            
            // now were ready to meld
            root = meld(ptr, root);
            
        } // while()
        
    } // updatePQ()


    
  
    virtual void push(const T &val)
    {
        addNode(val);
    } // push()
    
    
   
    virtual void pop()
    {
        if (isEmpty())
            throw std::runtime_error("Priority queue is empty");

        // placeholder
        Node *temp = root->child;
        
        // Reset the root before deleting the node
        root->child = nullptr;
        
        // pop the root
        delete root;
        numNodes--;
        
        // two cases: empty and not empty
        if (!temp)
        {
            // update the root
            root = nullptr;
        }
        else if (getSize() == 1)
        {
            temp->parent = nullptr;
            root = temp;
        }
        // not empty case
        else
        {
            // create a deque of pointers
            std::deque<Node*> dq;
        
            // fill it with the remaining heap
            while (temp)
            {
                dq.push_back(temp);
                temp = temp->sibling;
            }
            
            // we now perform a multi-pass on the dq
            while (dq.size() != 1)
            {
                size_t index = 0;
                
                // break the sibling parent relation
                dq[index]->parent = nullptr;
                dq[index]->sibling = nullptr;
                dq[index + 1]->parent = nullptr;
                dq[index + 1]->sibling = nullptr;
                
                // meld two elements and push them to back
               dq.push_back(meld(dq[index], dq[index + 1]));
                    
                // pop the ones that were just melded
                dq.pop_front();
                dq.pop_front();
            }
            
            // heap restored
            root = dq.front();
            dq.pop_front();
        }
        
    } // pop()
    
    
    
    virtual const T &getTop() const
    {
        if (isEmpty())
            throw std::runtime_error("Priority queue is empty");
        return root->elt;
    } // getTop()
    
    
    
    virtual std::size_t getSize() const
    {
        return numNodes;
        
    } // getSize()
    
    // Description: Return true if the pairing heap is empty.
    // Runtime: O(1)
    virtual bool isEmpty() const
    {
        // if root = null, empty
        return !root;
        
    } // isEmpty()
    
    
    
    void updateElt(Node* node, const T &new_value)
    {
        // check for precondition
        if (this->compareFunctor(node->elt, new_value))
        {
            // update elt
            node->elt = new_value;
            
            
            if (node->parent)
            {
                if (this->compareFunctor(node->parent->elt, new_value))
                {
                    // store the parent before i sever link
                    Node *p = node->parent;

                    // start at leftmost
                    Node *curr = p->child;

                    // check if I am leftmost
                    if (curr == node)
                    {
                        // give the old root a new child, which is leftmost's sibling
                        p->child = node->sibling;
                    }
                    // check for prev, sibling, and parent, then sever 3 links
                    else
                    {
                        // traverse until one before node
                        while (curr->sibling != node)
                        {
                            curr = curr->sibling;
                        }
                        
                        // sever the link
                        curr = nullptr;
                        
                    }
                    
                    // check for sibling and parent, then sever 2 links
                    node->parent = nullptr;
                    node->sibling = nullptr;
                    
                    // ready to meld (if second level, then update root)
                    if (p == root)
                        root = meld(p, node);
                    else
                        meld(p, node); 

                    
                }
            }
        }
        
    } // updateElt()
    
    
   
    Node* addNode(const T &val)
    {
        // use the new keyword here to create the new node
        Node *newNode = new Node{ val };
        
        // we have two cases: empty and size > 0
        
        
        if (isEmpty()) // give it to root
            root = newNode;
        else        // meld it
            root = meld(newNode, root);
        
        numNodes++;
        
        return root;
        
    } // addNode()



    /// @brief Print the heap structure for debugging.
    /// @note Uses level-order traversal to display the heap structure.
    void print() const 
    {
        std::cout << "PairingPQ structure (size=" << numNodes << "):\n";
        if (isEmpty()) {
            std::cout << "[empty]\n";
            return;
        }
        
        printTree(root, 0);
        std::cout << std::endl;
    }
    // print()
    
    
private:
    
    // Links two non null heaps: root a and root b (b is always the curr root)
    // these roots must not have a parent or siblings.
    Node* meld(Node *a, Node *b)
    {
        // get extreme
        if (this->compareFunctor(b->elt, a->elt))
        {
            // give b a new parent and sibling
            b->parent = a;
            b->sibling = a->child;
            
            // give a a new child
            a->child = b;
            
            // return the larger one
            return a;
        }
        
        // give a a new parent and sibling
        a->parent = b;
        a->sibling = b->child;
        
        // give b a new child
        b->child = a;
        
        // return the larger one
        return b;
        
    } // meld()



    /// @brief Recursively print the tree structure.
    /// @param node: Current node to print.
    /// @param depth: Current depth in the tree.
    void printTree(Node* node, int depth) const 
    {
        if (node == nullptr) return;
        
        // Print current node with indentation
        for (int i = 0; i < depth; ++i) {
            std::cout << "  ";
        }
        std::cout << node->elt << "\n";
        
        // Print all children
        Node* child = node->child;
        while (child != nullptr) {
            printTree(child, depth + 1);
            child = child->sibling;
        }
    } // printTree()

    
    // root of heap and size
    Node *root;
    size_t numNodes;
};





#endif // PAIRINGPQ_H


















CRIT:

MA got one bug but missed another smaller one.

MB is incorrect about pop() while loop condition and when numNodes == 1. Also, incorrect about the updateElt precondition check. 




























P5.2

Im still failing.



CRIT:

MB is way better.




P5.3:

Cool, im passing now but the code is not well documented. can you provide a version with helpful comments and function briefs like the print function that explain the mechanics and any non-obvious aspects and/or caveats. also incude a runtime analysis for each function. then can u clean up some code duplicate like the parent and sib sever in pop. abstract that functionality since its sprinkled around everywhere and pachage it into a helper to call from the relevant spots. i see atleast three spots . meld hascode dupe too. then update any functions that require exceptions but dont have them and provide a test case for each 2 verfy throw.


IE, 2-PART: COMMENTING AND ABSTRACTION





CRIT:


MA isnt commenting within funcs. it calls mulitpass twopass. it miss named the sever helper and gave incorrect documentation for it, ie, it does sever children! It missed an opportunity to use the sever helper within its removeNodeFromTree helper! I was expecting swap in meld, but it did an abstraction instead. MB got R-B CTOR, updatePQ, complexity incorrect. It didnt update meld, but did good with the sibling parent sever abstract. MB got updateElt wrong with a logic error or typo.













P5.4:

main tradeoff between prev and parent?






CRIT: 

I like MB #1 name, but they both got it. MA's #2 is wonky, i like MB's. 



























P6:






















































PX:

whats the runtime of updatePQ?


lets get it to O(n)




